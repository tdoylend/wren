// Generated automatically from src/optional/wren_opt_meta.wren. Do not edit.
static const char* metaModuleSource =
"class Meta {\n"
"  static getModuleVariables(module) {\n"
"    if (!(module is String)) Fiber.abort(\"Module name must be a string.\")\n"
"    var result = getModuleVariables_(module)\n"
"    if (result != null) return result\n"
"\n"
"    Fiber.abort(\"Could not find a module named '%(module)'.\")\n"
"  }\n"
"\n"
"  static eval(source) {\n"
"    if (!(source is String)) Fiber.abort(\"Source code must be a string.\")\n"
"\n"
"    var closure = compile_(source, false, false)\n"
"    // TODO: Include compile errors.\n"
"    if (closure == null) Fiber.abort(\"Could not compile source code.\")\n"
"\n"
"    closure.call()\n"
"  }\n"
"\n"
"  static compileExpression(source) {\n"
"    if (!(source is String)) Fiber.abort(\"Source code must be a string.\")\n"
"    return compile_(source, true, true)\n"
"  }\n"
"\n"
"  static compile(source) {\n"
"    if (!(source is String)) Fiber.abort(\"Source code must be a string.\")\n"
"    return compile_(source, false, true)\n"
"  }\n"
"\n"
"  static extend(target, source, signatures) {\n"
"    if (!(source is Class)) Fiber.abort(\"Source must be a class.\")\n"
"    if (!(target is Class)) Fiber.abort(\"Target must be a class.\")\n"
"    \n"
"    for (signature in signatures) {\n"
"        if (!(signature is String)) Fiber.abort(\"Signature must be a string.\")\n"
"        extend_(target, source, signature)\n"
"    }\n"
"  }\n"
"\n"
"  foreign static compile_(source, isExpression, printErrors)\n"
"  foreign static getModuleVariables_(module)\n"
"  foreign static extend_(target, source, signature)\n"
"}\n";
